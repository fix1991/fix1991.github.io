---
title: 数据库和中间件面试题
createTime: 2024/11/24 15:56:15
permalink: /notes/interview/st8aupzd/
---

## 数据库

### 事务ACID特性

原子性、一致性、隔离性、持久性

### 脏读、不可重复读、幻读

- 脏读，事务A修改了某些数据，但尚未提交；事务B读取了这些未提交的数据
- 不可重复读，事务A读取了某些数据；事务B修改了这些数据并提交，导致事务A再次读取同样的数据时，得到不一样的结果
- 幻读，事务A读取某个范围内的几条数据，尚未提交；此时，事务B插入了一条新的数据，并提交；事务A再次读取同一范围内的数据时，结果集中出现了新的数据。

### 事务隔离级别

- READ UNCOMMITTED（读未提交），存在脏读、不可重复读、幻读的问题
- READ COMMITTED（读已提交），存在不可重复读、幻读的问题
- REPEATABLE READ（可重复读），存在幻读的问题
- SERIALIZABLE（序列化）

### MVCC机制

MVCC（Multi-Version Concurrency Control，多版本并发控制）。

核心思想：

1. **版本控制：** 在执行数据更新操作时，不是直接覆盖原始数据，而是生成一个新的数据版本，并将新版本的数据写入到数据库中。这样，原始数据仍然保留在数据库中，不会被覆盖。
2. **版本检查：** 在执行查询操作时，数据库会根据事务的隔离级别，检查事务开始时数据库中的数据版本，并根据数据版本的可见性规则来确定事务能够看到哪些数据。

### MySQL锁

- 表锁

- 行级锁，InnoDB 存储引擎使用行级锁
- 页锁
- 间隙锁，锁定记录前后的间隙，防止幻读

死锁问题

### 索引

#### MySQL中索引的类型

B-Tree索引

自适应哈希索引

全文索引

单列索引、多列索引、前缀索引

#### MySQL索引匹配规则

全值匹配

最左前缀匹配

列前缀匹配

范围匹配

#### 聚簇索引

聚簇索引将数据行存储在索引的叶子节点中，而非聚簇索引只存储指向数据行的指针。

InnoDB默认使用主键作为聚簇列；如果没有主键，则选择一个唯一非空索引代替；如果没有，隐式创建一个主键作为聚簇索引列。

#### 覆盖索引

一个查询可以通过索引直接获取所需要的数据，而不需要回表查询。

### sql优化



### `explain`查看sql执行计划



### 慢查询优化

1. 使用`explain`分析sql执行计划
2. 优化索引
3. 优化查询条件
4. 优化表结构
5. 分析数据量，考虑分库、分表
6. 使用缓存
7. 定期优化数据库，索引优化、更新索引统计信息



### MySQL主从同步原理



### MySQL分区、分库、分表



## Redis

### Redis支持的数据结构

字符串、列表、集合、有序集合、哈希、Bitmap、HyperlogLog、地理空间坐标

### Bitmap数据结构

### HyperlogLog数据结构

### Redis事务

`multi`、`exec`、`discard`、`watch`、`unwatch`

### RDB和AOF持久化机制

### Redis主从复制

主从拓扑结构：一主一从、一主多从、多层结构。

主从复制的流程：保存主节点信息、建立socket连接、发送ping命令、验证权限、全量复制、增量复制

### Redis哨兵

哨兵节点、数据节点（主节点+从节点）。

### Redis集群

数据分区的方式：节点取余分区、一致性哈希分区（哈希环）、**虚拟槽分区**。

### Redis应用场景

计数器、访问频率限制、缓存、HTTP Session共享、排行榜、实现栈和队列、分布式锁

### Redis缓存

**缓存更新策略：**

- 超出设置的最大内存后剔除：设置缓存最大内存占用，超出设置值后剔除最早的缓存
- 超时剔除
- 主动更新

**缓存穿透、击穿、雪崩：**

- 缓存击穿：缓存层未命中、存储层命中，频繁查询导致存储层负载过高。

- 缓存穿透：缓存层和存储层都未命中。

- 缓存雪崩：缓存中大量的key均为命中、存储层压力过大导致崩溃

优化措施，核心就是保证缓存层高可用：

- 缓存空值
- 使用布隆过滤器，过滤不存在的key
- 延长热点Key过期时间
- 给访问存储层的代码加互斥锁，只允许一个线程查询数据库、更新缓存
- 接口限流
- 采用高可用架构：读写分离、哨兵、集群

### 慢查询问题

`slowlog get [count]`

### BigKey问题

BigKey危害：集群中内存分布不均匀、Redis阻塞、网络超时

发现BigKey：`redis-cli --bigkeys`

删除BigKey：字符串类型可以直接删除，非字符串类型推荐分批删除

### HotKey问题

延长热点Key过期时间、如果热点Key包含2级数据，可将其拆分为多个Key。

### Redis实现分布式锁

**基于setnx和expire**

考虑使用lua脚本保证加锁、释放锁等操作的原子性

```java
private void foo(String key) {
    Jedis redis = RedisClient.getClient();
    String mutexLockKey = String.format("mutex:%s", key);
    SetParams params = SetParams.setParams()
        .nx()
        .ex(5L);
    if(redis.set(mutexLockKey, "1", params) != null) {
        // 获取锁成功:
        try {
            // 执行业务代码
        }finally {
            // 释放锁
            redis.del(mutexLockKey);
        }
    }else{
        // 获取锁失败: 休眠一段时间后重试
        try {
            TimeUnit.SECONDS.sleep(5L);
            foo(key);
        } catch(InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

**使用Redission**

略

## 消息中间件

### RabbitMQ架构模式

消息发布者、消息消费者、交换机、队列、绑定、路由键

### RabbitMQ交换机类型

- direct：直接交换机，路由键完全匹配

- fanout：广播模式

- topic：主题模式 `a.*.*`、`a.#`

- headers：消息headers属性

### RabbitMQ如何解决消息积压的问题

- 消费者限流：使用公平分发策略（`Channel#basicQos`方法），设置每个消费者能够同时处理的未确认消息的最大数量
- 设置消息TTL，自动删除过期消息
- 限制队列长度：设置队列的最大长度，超出队列长度限制时，RabbitMQ自动删除最早的消息
- 死信队列：声明队列时，设置死信交换器，将无法处理的消息路由到死信队列，监控死信队列中的消息数量来识别和处理消息积压问题
- 限制消息发送方发送消息的频率，增大消息消费方消费消息的能力

### RabbitMQ如何保证消息的可靠性

- 确保消息成功发送到交换机：事务机制、消息发布方确认机制
- 确保消息被消费后才从消息队列删除：消息消费方确认机制
- 持久化：持久化交换机、队列、消息
- 备用交换机：声明交换机时，设置备用交换机，将无法处理的消息转发到备用交换机，进而路由到备用消息队列

### RabbitMQ死信队列、延迟队列、优先级队列

## ELK



## MinIO